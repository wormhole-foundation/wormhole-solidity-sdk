import { toCapsSnakeCase } from "./utils";
import {
  platformToChains,
  nativeChainIds,
  contracts,
  rpc,
  circle,
} from "@wormhole-foundation/sdk-base";
import { EvmAddress } from "@wormhole-foundation/sdk-evm";

const {networkChainToNativeChainId} = nativeChainIds;
const {coreBridge, tokenBridge, relayer, circleContracts, executor} = contracts;
const {usdcContract, circleChainId} = circle;

console.log(
`// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

// ╭──────────────────────────────────────╮
// │ Auto-generated by gen/chainConsts.ts │
// ╰──────────────────────────────────────╯

// This file contains:
//  * 2 libraries
//  * an associated set of free standing functions
//  * additional free standing functions for looking up chain constants by EVM chain ID
//
// The libraries:
//  1. MainnetChainConstants
//  2. TestnetChainConstants
//
// Both provide the same set of functions, which are also provided as free standing functions
//   with an additional network parameter, though library functions use an underscore prefix to
//   avoid a declaration shadowing bug that has been first reported in the solc Github in 2020...
//   see https://github.com/ethereum/solidity/issues/10155
//
//          Function        │ Parameter │  Returns
//  ────────────────────────┼───────────┼────────────
//   chainName              │  chainId  │  string
//   defaultRPC             │  chainId  │  string
//   coreBridge             │  chainId  │  address
//   tokenBridge            │  chainId  │  address
//   wormholeRelayer        │  chainId  │  address
//   executor               │  chainId  │  address
//   cctpDomain             │  chainId  │ cctpDomain
//   usdc                   │  chainId  │  address
//   cctpMessageTransmitter │  chainId  │  address
//   cctpTokenMessenger     │  chainId  │  address
//
// Empty fields return invalid values (empty string, address(0), INVALID_CCTP_DOMAIN)
//
// Additional free standing evmChainId-based functions:
//
//       Function       │  Parameter   │  Returns
//  ────────────────────┼──────────────┼────────────────────────────────
//   isSupported        │  evmChainId  │  bool
//   networkAndChainId  │  evmChainId  │ (bool mainnet, uint16 chainId)

import "wormhole-sdk/constants/Chains.sol";
import "wormhole-sdk/constants/CctpDomains.sol";

uint32 constant INVALID_CCTP_DOMAIN = type(uint32).max;
error UnsupportedEvmChainId(uint256 evmChainId);
error UnsupportedChainId(uint16 chainId);
`
);

const evmChains = platformToChains("Evm");
type EvmChain = typeof evmChains[number];
const networks = ["Mainnet", "Testnet"] as const;

const networkChains = {
  Mainnet: evmChains.filter(chain =>
    contracts.coreBridge.has("Mainnet", chain)),
  //remove testnets that were superseded by Sepolia testnets
  Testnet: evmChains.filter(chain =>
    contracts.coreBridge.has("Testnet", chain) &&
    chain !== "Ethereum" &&
    !evmChains.includes(chain + "Sepolia" as EvmChain)
  )
}

type Lines = string | string[];
const indent = <const L extends Lines>(lines: L): string[] =>
  ( typeof lines === "string"
  ? indent(lines.split("\n"))
  : lines.map(line =>
    line === "" ? "" : "  " + line)
  ) as any;

const block = (head: string, body: Lines, curly: boolean) =>
  [ head + ` ` + (curly ? "{" : "("),
    ...indent(body),
    curly ? "}" : ");",
  ].join("\n");

const functionBlock = (head: string, body: Lines) => block("function " + head, body, true);

console.log(
  [ functionBlock(
      `_networkAndChainIdImpl(uint256 evmChainId) pure returns (bool mainnet, uint16 chainId)`,
      [ ...networks.flatMap(network =>
          networkChains[network].flatMap(chain => [
            `if (evmChainId == ${networkChainToNativeChainId(network, chain as any)})`,
            ...indent(`return (${network === "Mainnet"}, CHAIN_ID_${toCapsSnakeCase(chain)});`),
          ]),
        ),
        `return (false, CHAIN_ID_UNSET);`,
      ]
    ),
    functionBlock(
      `isSupported(uint256 evmChainId) pure returns (bool)`,
      [ `(, uint16 chainId) = _networkAndChainIdImpl(evmChainId);`,
        `return chainId != CHAIN_ID_UNSET;`,
      ]
    ),
    functionBlock(
      `networkAndChainId(uint256 evmChainId) pure returns (bool mainnet, uint16 chainId)`,
      [ `(mainnet, chainId) = _networkAndChainIdImpl(evmChainId);`,
        `if (chainId != CHAIN_ID_UNSET)`,
        ...indent(`return (mainnet, chainId);`),
        `revert UnsupportedEvmChainId(evmChainId);`,
      ]
    )
  ].join("\n\n") + "\n"
);

enum AliasType {
  String     = "string",
  Address    = "address",
  CctpDomain = "uint32",
}

const emptyValue = {
  [AliasType.String    ]: "",
  [AliasType.Address   ]: "address(0)",
  [AliasType.CctpDomain]: "INVALID_CCTP_DOMAIN",
}

const returnParam = (aliasType: AliasType) =>
  aliasType === AliasType.String ? "string memory" : aliasType;

const toReturnValue = (value: string, returnType: AliasType) => {
  if (returnType === AliasType.Address && value)
    return new EvmAddress(value).toString(); //ensures checksum format

  const ret = value || emptyValue[returnType];
  return returnType === AliasType.String
    ? `\"${ret}\"`
    : ret;
}

const functions = [
  ["chainName",              AliasType.String    ],
  ["defaultRPC",             AliasType.String    ],
  ["coreBridge",             AliasType.Address   ],
  ["tokenBridge",            AliasType.Address   ],
  ["wormholeRelayer",        AliasType.Address   ],
  ["executor",               AliasType.Address   ],
  ["cctpDomain",             AliasType.CctpDomain],
  ["usdc",                   AliasType.Address   ],
  ["cctpMessageTransmitter", AliasType.Address   ],
  ["cctpTokenMessenger",     AliasType.Address   ],
] as const;

console.log(
  functions.map(([name, returnType]) =>
    functionBlock(
      `${name}(bool mainnet, uint16 chainId) pure returns (${returnParam(returnType)})`,
      [ `return mainnet`,
        ...indent(`? MainnetChainConstants._${name}(chainId)`),
        ...indent(`: TestnetChainConstants._${name}(chainId);`),
      ]
    ),
  ).join("\n\n") + "\n"
);

console.log(
  networks.map(network => {
    const functionDefinition = (
      name: string,
      returnType: AliasType,
      mapping: (chain: EvmChain) => string,
    ) => functionBlock(
      `_${name}(uint16 chainId) internal pure returns (${returnParam(returnType)})`,
      [ ...networkChains[network].flatMap(chain => [
          `if (chainId == CHAIN_ID_${toCapsSnakeCase(chain)})`,
          ...indent(`return ${toReturnValue(mapping(chain), returnType)};`),
        ]),
        `revert UnsupportedChainId(chainId);`
      ]
    );

    const cctpDomainConst = (chain: EvmChain) =>
      circleChainId.has(network, chain)
        ? `CCTP_DOMAIN_${toCapsSnakeCase(chain)}`
        : "INVALID_CCTP_DOMAIN";

    const mappings = {
      chainName:              chain => chain,
      defaultRPC:             chain => rpc.rpcAddress(network, chain),
      coreBridge:             chain => coreBridge.get(network, chain),
      tokenBridge:            chain => tokenBridge.get(network, chain),
      wormholeRelayer:        chain => relayer.get(network, chain),
      executor:               chain => executor.get(network, chain),
      cctpDomain:             chain => cctpDomainConst(chain),
      usdc:                   chain => usdcContract.get(network, chain),
      cctpMessageTransmitter: chain => circleContracts.get(network, chain)?.messageTransmitter,
      cctpTokenMessenger:     chain => circleContracts.get(network, chain)?.tokenMessenger,
    };

    return block(
      `library ${network}ChainConstants`,
      functions
        .map(([name, returnType]) => functionDefinition(name, returnType, mappings[name]))
        .join("\n\n"),
      true,
    );
  }).join("\n\n")
);
